# 任务系统设计文档

## 1. 项目介绍

本任务系统旨在为《大道朝天》项目构建一个动态、沉浸式、由 AI 驱动的任务体验。系统不仅包含传统的主线、支线任务，更核心的是利用大语言模型（LLM）根据玩家的行为、状态和所处环境，动态生成符合当前世界观和修仙背景的“机缘”或“试炼”任务，从而极大增强游戏的可玩性和个性化体验。

## 2. 核心设计理念

- **情境驱动 (Context-Aware)**：任务的生成与玩家当前的角色境界、位置、已完成事件、人际关系等强相关。
- **动态演进 (Dynamic)**：任务链会根据玩家的选择产生不同分支，任务目标也可能在执行过程中发生变化。
- **奖励闭环 (Rewarding)**：完成任务将给予玩家明确的成长反馈，包括修为、道具、功法、声望等，构成正向激励循环。
- **高度集成 (Integrated)**：任务系统将与游戏内其他系统（如背包、技能、地图、NPC关系）深度耦合。

## 3. 任务数据结构 (Data Structure)

为了支撑动态任务系统，我们需要一个灵活且可扩展的数据结构。这份结构将同时用于前后端的数据交互和数据库存储。

建议在 `src/types/` 目录下创建一个新文件 `task.d.ts` 来定义前端类型，并在 `server/schemas/schema.py` 和 `server/models.py` 中定义后端结构。

### TypeScript (前端)

```typescript
// src/types/task.d.ts

export interface TaskObjective {
  id: string; // 目标唯一ID
  description: string; // 目标描述，例如：“击败10只黑风狼”或“采集5株凝血草”
  type: 'KILL' | 'GATHER' | 'TALK' | 'REACH' | 'USE_ITEM'; // 目标类型
  targetId: string; // 目标ID (怪物ID, 物品ID, NPC_ID, 地点坐标字符串等)
  requiredAmount: number; // 需要数量
  currentAmount: number; // 当前进度
  isCompleted: boolean; // 是否完成
}

export interface TaskReward {
  experience?: number; // 奖励经验/修为
  currency?: {
    type: 'spirit_stone'; // 货币类型，如灵石
    amount: number;
  };
  items?: {
    itemId: string; // 物品ID
    quantity: number;
  }[];
  reputation?: {
    factionId: string; // 势力ID
    change: number; // 声望变化
  };
  // 其他特殊奖励，如功法、称号等
}

export interface Task {
  id: string; // 任务唯一ID
  title: string; // 任务标题
  description: string; // 任务详细描述
  type: 'MAIN' | 'SIDE' | 'SECT' | 'EVENT' | 'DAILY'; // 任务类型：主线/支线/宗门/奇遇/日常
  status: 'INACTIVE' | 'ACTIVE' | 'COMPLETED' | 'FAILED'; // 任务状态：未接取/进行中/已完成/已失败
  objectives: TaskObjective[]; // 任务目标列表
  preconditions?: {
    level?: number; // 等级/境界要求
    completedTaskId?: string; // 前置任务ID
    reputation?: { factionId: string; min: number; }; // 声望要求
  };
  rewards: TaskReward; // 任务奖励
  issuerNpcId?: string; // 任务发布者NPC ID
  turnInNpcId?: string; // 任务交付NPC ID
  isAiGenerated: boolean; // 是否由AI生成
  createdAt: string; // 任务创建时间
  updatedAt: string; // 任务更新时间
}
```

### Python (后端 - Pydantic Schema)

```python
# server/schemas/schema.py

from pydantic import BaseModel
from typing import List, Optional, Dict, Any

class TaskObjectiveBase(BaseModel):
    description: str
    type: str  # 'KILL', 'GATHER', 'TALK', 'REACH', 'USE_ITEM'
    targetId: str
    requiredAmount: int
    currentAmount: int = 0
    isCompleted: bool = False

class TaskRewardBase(BaseModel):
    experience: Optional[int] = None
    currency: Optional[Dict[str, Any]] = None
    items: Optional[List[Dict[str, Any]]] = None
    reputation: Optional[List[Dict[str, Any]]] = None

class TaskBase(BaseModel):
    title: str
    description: str
    type: str  # 'MAIN', 'SIDE', 'SECT', 'EVENT', 'DAILY'
    status: str = 'ACTIVE'
    objectives: List[TaskObjectiveBase]
    rewards: TaskRewardBase
    isAiGenerated: bool = True
    issuerNpcId: Optional[str] = None
    turnInNpcId: Optional[str] = None

class TaskCreate(TaskBase):
    pass

class TaskUpdate(BaseModel):
    status: Optional[str] = None
    objectives: Optional[List[TaskObjectiveBase]] = None

class TaskInDB(TaskBase):
    id: str
    owner_id: str # 角色ID

    class Config:
        orm_mode = True
```

## 4. AI 提示词 (Prompts) 设计

这是动态任务系统的核心。提示词需要清晰、结构化，并能引导 AI 输出我们需要的 JSON 格式。

### 任务生成 (Generate)

此提示词用于根据玩家当前状态生成一个新任务。

```text
# Role: 天道世界引擎 - 任务生成器

## Profile
你是一个富有创造力的游戏设计师，专精于设计东方仙侠世界的任务。你的任务是根据玩家的当前状态和世界背景，创造一个合理、有趣且符合逻辑的修仙任务。

## Context
- **世界背景**: {world_lore}
- **玩家信息**:
  - 姓名: {player_name}
  - 境界: {player_realm}
  - 位置: {player_location}
  - 最近事件: {recent_events}
  - 背包物品: {player_inventory}
  - 人际关系: {player_relationships}

## Rules
1.  **严格遵循JSON格式**: 你的输出必须是严格的、不含任何额外注释的JSON对象。
2.  **逻辑自洽**: 任务的起因、目标和奖励必须符合仙侠世界的逻辑。一个炼气期修士不应接到屠龙任务。
3.  **目标明确**: 任务目标必须是具体、可量化的，例如击杀特定怪物、采集特定草药、与特定NPC对话或到达某个地点。
4.  **类型匹配**: 根据情境生成合适的任务类型。例如，在宗门附近可生成 `SECT` 任务，野外偶遇受伤的修士可生成 `EVENT` (奇遇) 任务。
5.  **奖励平衡**: 奖励要与任务难度相匹配。

## Output Format (JSON)
请严格按照以下结构和字段输出，不要添加任何多余的键或解释。

{
  "title": "任务标题 (简洁明了)",
  "description": "任务的详细背景故事和描述 (生动形象)",
  "type": "任务类型 (从 'SIDE', 'SECT', 'EVENT' 中选择)",
  "objectives": [
    {
      "description": "目标描述 (例如：'前往青木林采集3株洗髓花')",
      "type": "目标类型 (从 'KILL', 'GATHER', 'TALK', 'REACH' 中选择)",
      "targetId": "目标ID (例如：'item_xisuihua', 'npc_zhanglao', 'loc_qingmulin')",
      "requiredAmount": 3
    }
  ],
  "rewards": {
    "experience": 150,
    "currency": { "type": "spirit_stone", "amount": 20 },
    "items": [{ "itemId": "item_healing_potion", "quantity": 2 }]
  },
  "issuerNpcId": "npc_cunzhzhang (如果适用)",
  "turnInNpcId": "npc_cunzhzhang (如果适用)"
}

## Task
现在，请根据以上信息，为玩家 `{player_name}` 生成一个新任务。
```

### 任务更新/演进 (Update)

当玩家做出某个选择或达成某个阶段性目标时，可以用此提示词来动态调整任务。

```text
# Role: 天道世界引擎 - 任务演进器

## Profile
你是一个应变能力极强的游戏叙事者。你的工作是根据玩家在任务中的行为，动态调整任务的后续发展，使其更具戏剧性和不可预测性。

## Context
- **当前任务状态**: {current_task_json}
- **玩家刚刚完成的动作**: {player_action}

## Rules
1.  **保持连贯性**: 你的调整必须基于当前任务，不能凭空捏造。
2.  **创造意外**: 可以是任务目标变更、出现新的敌人/盟友，或者发现任务背后的真相。
3.  **严格JSON输出**: 你的输出必须是一个只包含已变更字段的JSON对象。

## Output Format (JSON)
输出一个包含 `description` (新的任务描述) 和/或 `objectives` (新的目标列表) 的JSON对象。

{
  "description": "（可选）更新后的任务描述，解释为什么发生了变化。",
  "objectives": [
    {
      "description": "新的目标描述",
      "type": "...",
      "targetId": "...",
      "requiredAmount": "..."
    }
  ]
}

## Task
玩家在执行任务“{current_task.title}”时，刚刚 {player_action}。请判断是否需要对任务进行演进，并给出更新的JSON。如果无需变化，请返回空JSON对象 `{}`。
```

## 5. 代码实现建议

### 后端 (Python / FastAPI)

1.  **创建任务模型**：在 `server/models.py` 中，根据上面的数据结构创建一个 `Task` ORM 模型，并与 `User` 模型关联。
2.  **创建API路由**：在 `server/api/api_v1/endpoints/` 目录下新建 `tasks.py` 文件。
    -   `POST /api/v1/tasks/generate`: 接收玩家ID，从数据库获取玩家信息，组装成任务生成Prompt，调用AI服务，然后将返回的JSON存入数据库。
    -   `GET /api/v1/characters/{character_id}/tasks`: 获取指定角色的所有任务列表。
    -   `POST /api/v1/tasks/{task_id}/update`: 接收玩家的动作（如 `kill_monster`, `gather_item`），更新任务进度。这个接口内部可以触发任务演进的AI调用。
    -   `POST /api/v1/tasks/{task_id}/complete`: 验证任务是否所有目标都已完成，如果完成，则发放奖励并更新任务状态。

### 前端 (Vue / TypeScript)

1.  **创建任务Store**：在 `src/stores/` 目录下新建 `taskStore.ts` (使用Pinia)。
    -   `state`: `tasks: Task[]`, `isLoading: boolean`。
    -   `actions`:
        -   `fetchTasks()`: 调用后端API获取任务列表。
        -   `generateNewTask()`: 调用后端生成新任务的API，并更新本地列表。
        -   `updateTaskProgress(taskId, objectiveId, progress)`: 通知后端任务进度更新。
        -   `completeTask(taskId)`: 通知后端完成任务。
2.  **创建API服务**：在 `src/services/` 目录下新建 `taskService.ts`，封装所有与任务相关的HTTP请求。
3.  **修改UI组件**：
    -   **`src/components/dashboard/QuestPanel.vue`**: 这是任务系统的主要展示界面。
        -   从 `taskStore` 获取任务列表并展示。
        -   区分不同类型的任务（主线、支线等）并用不同图标或颜色标识。
        -   点击某个任务，可以展开显示详细描述、目标进度和奖励。
        -   提供一个“刷新机缘”按钮，手动调用 `generateNewTask` 动作，给玩家一种主动探索的感觉。
    -   **`src/components/dashboard/MainGamePanel.vue`**: 当玩家完成一个任务目标时（例如击杀一个特定怪物），游戏主面板需要捕获这个事件，并调用 `taskStore.updateTaskProgress()`。

## 6. 总结

该方案提供了一个从设计到实现的全流程蓝图。核心优势在于利用 AI 实现了任务的动态生成和演进，打破了传统静态任务的局限性。

**下一步行动建议**：
1.  根据本文档在前后端分别建立好数据结构。
2.  优先实现后端的任务生成和查询API，并与AI模型服务对接。
3.  在前端 `QuestPanel.vue` 中实现任务列表的展示。
4.  逐步实现任务进度更新和完成的逻辑闭环。