### **项目核心思路结构化**

本项目旨在构建一个高度自定义、AI驱动的沉浸式叙事/游戏平台，核心在于AI记忆管理、多世界支持及用户深度交互。

**I. 核心AI记忆与上下文管理系统**

此部分是确保AI能够理解、记住并连贯生成内容的关键。

- **A. 多存档实现：**
  - **机制：** 系统应支持创建多个独立的存档。每个存档将拥有独立的记忆链、当前会话状态以及关联的世界书引用。用户可以随时切换不同的存档，进行独立的游玩体验。
  - **数据存储：** 每个存档的核心数据（如角色状态、世界书绑定、记忆链条）独立存储，确保互不干扰。

- **B. 记忆层次划分与管理：**
  - **目标：** 优化AI上下文窗口的使用效率，平衡记忆的时效性、细节度和持久性。
  - **层次构成：**
    1.  **最新完整消息 (Short-term/Current Context):**
        - **数量：** 维持在一个较小的固定数量（例如，**最新的5条消息**）。
        - **作用：** 确保AI对用户当前对话和最近事件有最直接、最完整的把握，保持对话的即时性和连贯性。
        - **管理：** 每次新消息生成后，最旧的一条将被挤出这个列表，进入中期记忆缓存区域。
    2.  **中期记忆 (Mid-term Memory):**
        - **生成机制：** 当最新的完整消息积累到一定数量（或根据固定消息数量触发）后，AI 会在生成正文的同时，对这些消息进行摘要并生成一段总结作为中期记忆。
        - **数量控制：** 用户可以自定义需要总结的中期记忆数量阈值（例如，**积累20条消息后开始转化**）。
        - **转化策略：**
          - **非全部转化：** 不会将累积的所有中期记忆全部转化为长期记忆。
          - **衔接保留：** 每次转化时，会保留一部分最新的中期记忆（例如，**20条中期记忆中，保留5-10条最新**的以便保持上下文衔接），其余的则等待转化为长期记忆。
        - **原因（为何不存世界书）：** 中期记忆的特点是具有一定的时效性和细节性，且处于**动态变化和频繁更新**中。若直接存入世界书，会造成世界书内容臃肿、更新频率过高，且可能引入过多的琐碎细节，影响长期记忆的抽象性和稳定性。通过独立管理，可提供更灵活的记忆转化机制。
    3.  **长期记忆 (Long-term Memory):**
        - **来源：** 由中期记忆经过进一步的总结、提炼和归纳后转化而来。
        - **数量：** 建议设定一个固定数量上限（例如，**最终存储30条长期记忆**）。
        - **作用：** 存储游戏世界中关键的事件、人物关系、剧情发展、玩家行为模式等宏观信息，作为AI生成内容的基石。
        - **原因（为何不存世界书）：** 长期记忆通常是与角色个体或特定会话进程相关的，而非世界观设定本身。将其存入独立记忆系统而非世界书，可以保持世界书的通用性和稳定性，同时确保每个角色的个性化记忆得到有效管理。每次对话发送时，将其附加到AI的 prompts 中。
  - **转化频率控制：**
    - **避免频繁：** 中期记忆向长期记忆的转化不应过于频繁。
    - **用户体验：** 频繁的转化（通过AI前端提示词总结）可能导致AI响应时间变长，影响用户在“酒馆”模式下的流畅体验。
    - **触发条件：** 可以设置为达到特定中期记忆数量时触发，或通过时间间隔触发。

- **C. 记忆提取与注入机制：**
  - **AI提取：** 在AI生成正文时，它需要能够**有效地提取**当前上下文中所需的最新消息、中期记忆和长期记忆，以确保生成内容的准确性和连贯性。
  - **传输格式：** 记忆应以结构化、易于AI理解的方式拼接进每次调用的Prompt中。例如：
    ```
    [系统指令]
    ...
    [世界背景设定] (来自世界书)
    ...
    [长期记忆]
    - 事件A：...
    - 事件B：...
    ...
    [中期记忆]
    - 近期总结1：...
    - 近期总结2：...
    ...
    [最新对话和行动]
    - 用户：...
    - AI：...
    ...
    [用户最新输入]
    ...
    ```

**II. 接口设计与用户体验优化**

为提供流畅且可控的用户体验，需要设计灵活的接口。

- **A. 双接口策略：**
  1.  **“酒馆”主接口 (Tavern API):**
      - **功能：** 主要用于用户与AI进行实时、交互式对话和游戏。
      - **特点：** 要求高响应速度，低延迟。
      - **处理：** 负责最新消息的接收与发送、基础的记忆注入。中期记忆的总结与转化操作**不应在此主流程中进行**，以免卡住用户。
  2.  **“总结与转化”额外接口 (Summary & Conversion API):**
      - **功能：** 专门用于异步处理中期记忆的总结和向长期记忆的转化。
      - **用户可见性：**
        - **可选配置：** 用户可以在设置中选择是否启用此接口。
        - **自定义填写：** 用户可自行填写此接口的地址和API Key。
      - **接口规范：**
        - **标准兼容：** 建议采用兼容OpenAI API的标准规范（如New-api最常用）。这样用户可以方便地使用已有的兼容接口或自建服务。
        - **输入/输出：** 接收需要总结的消息列表，返回总结后的文本或结构化记忆。
      - **调用方式：** 当达到中期记忆转化条件时，前端（或后端服务）**异步调用此接口**，将待总结的中期记忆发送过去，AI处理完成后再将结果更新到用户记忆库。

- **B. 前端与AI交互：**
  - **判定提示词：** 将具体的判定逻辑（如“用户要战斗”）封装为前端提示词，在特定场景下附加到用户的请求中发送给AI。
  - **AI返回格式化消息：** AI应被引导按照预设的格式（如JSON）返回结果，以便前端解析、修改数据和展示判定结果。
  - **AI出错处理（格式不符）：**
    - **前端解析策略：** 前端应设计鲁棒的解析机制，例如：
      - **严格匹配：** 首先尝试严格匹配预设格式。
      - **模糊匹配/关键字识别：** 若严格匹配失败，尝试通过关键字或模式识别提取关键信息。
      - **回退机制：** 若仍无法解析，可以尝试将AI返回的原始文本展示给用户，或进行错误提示。
      - **修正指令：** 更高级的处理方式是，当前端检测到AI返回格式错误时，可以**自动向AI发送一条修正指令**，要求其重新按照预设格式输出。

**III. 多世界书与内容自定义系统**

实现内容的高度可定制化和扩展性。

- **A. 多世界书架构：**
  - **概念：** 允许存在多个独立的“世界书”，每个世界书包含其独特的世界背景设定。
  - **默认世界书：** 提供一个默认的“大道朝天”世界书，包含初步的世界背景设定、基础规则等。
  - **用户绑定：** 每个用户存档可以绑定到一个特定的世界书。

- **B. 内容划分与协调：**
  - **世界书内容：** 主要存放**通用且固定**的世界观设定，如：
    - 世界背景、历史、地理、主要势力、基础规则（如修仙体系通用规则）。
  - **前端提示词内容：** 主要承载**场景化、短期或动态**的指令，如：
    - 战斗判定提示词、特定交互提示、当前任务目标、角色临时状态等。
  - **协调：** AI在生成内容时，应优先加载所绑定世界书的设定，并结合前端提供的场景提示词进行创作。

- **C. 用户自定义内容：**
  - **世界背景自定义：**
    - **方式：** 允许用户提交自定义的世界背景设定。
    - **协调：** 这部分内容需集成到用户自建或选择的世界书中。
    - **冲突规避：** 在用户上传自定义世界背景时，需要有机制检查其与核心规则（如境界体系）是否存在**冲突**。
  - **境界设定：**
    - **前端定死/随机：**
      - **默认：** 可以在前端提供一套默认的境界体系和对应的颜色序列（例如，从低到高依次为白、绿、蓝、紫、金等），确保基础的视觉和规则统一性。
      - **自定义：** 允许用户在设定自定义世界背景时，**自定义境界名称、描述，并为每个境界选择对应的颜色**，前端只需按照用户的设定进行展示。确保境界的属性（如高低层级）不冲突。
  - **天赋设定：** 允许用户自定义角色的天赋。

**IV. 数据同步、安全与管理**

确保用户数据的持久性、安全性及内容的规范性。

- **A. 内容云端同步：**
  - **同步对象：**
    - **天赋设定：** 用户AI生成或自定义的天赋应能同步到云端，方便用户在不同设备上或新的存档中复用。
    - **世界背景设定：** 用户提交的自定义世界背景，在审核通过后，可以考虑同步到云端，供其他用户选择（如果这是产品的方向）。
  - **安全性：** 云端存储需考虑数据加密、访问权限控制等措施，确保用户数据的安全。

- **B. 世界背景提交与管理：**
  - **格式规范：**
    - 为防止AI出错或数据混乱，用户提交的世界背景需要一个**严格的结构化格式**。建议采用JSON或YAML格式，包含明确的字段，例如：`worldName`、`description`、`history`、`majorFactions`、`keyLocations`、`realmSystem` (境界体系详细信息)、`uniqueSetting`等。
    - **境界属性冲突：** 在`realmSystem`字段中，应规定境界的层次结构和关联属性，**确保前端定死的或用户自定义的颜色、等级等属性不冲突**。
  - **防止用户频繁提交：**
    - **目的：** 世界背景的重要性决定了其不应被随意、频繁地更改。
    - **机制：** 除了兑换码机制，还可以考虑：
      - **提交间隔限制：** 对单个用户或IP的提交频率进行限制。
      - **人工审核/自动审核：** 新提交的世界背景需要经过审核才能生效。
      - **版本管理：** 允许用户提交更新版本，但保留历史版本。

- **C. 兑换码机制集成：**
  - **目的：** 作为提交世界背景的准入门槛，确保只有经过授权或分发的用户才能提交内容，从而规范内容质量。
  - **集成方式（PHP实现考量）：**
    - **集成：** 将兑换码验证逻辑**直接集成到世界背景提交的API接口中**。即，用户提交世界背景时，必须同时提供一个有效的兑换码，服务器端PHP代码接收请求后，首先验证兑换码的有效性（是否未被使用、是否过期等），验证通过后才处理世界背景的存储或更新。
    - **修改：** 若不集成，则意味着兑换码的管理和验证逻辑独立存在，世界背景提交接口可能仍需通过某种方式（如与兑换码服务进行内部通信）来判断用户是否有权限。
    - **建议：** **强烈建议将兑换码验证逻辑直接集成到世界背景提交的API中**。这样能够在一个请求生命周期内完成权限判断，结构更紧凑，也便于管理。PHP后端负责兑换码的生成、分发、验证和一次性销毁（如果兑换码是一次性的）等功能。

---

通过以上结构化，相信能更清晰地指导项目的开发和实现。
