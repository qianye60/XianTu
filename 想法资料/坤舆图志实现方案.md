# 坤舆图志·实现方案 (Leaflet.js Integration Plan)

此方案旨在为“大道朝天”项目规划并设计基于 `Leaflet.js` 的交互式地图系统——“坤舆图志”。方案的核心是将AI生成的世界地理与势力信息，转化为可视化的、可交互的地图元素。

## 一、 天机演化：AI数据输出规范

为使地图系统能理解AI生成的世界，AI必须以标准化的 **GeoJSON** 格式输出地图信息。此格式是地图数据的通用语言，能被 Leaflet 直接解析。

我们将在 `src/utils/tavernAI.ts` 的 `MAP_GENERATION_PROMPT` 中，要求AI返回如下结构的JSON：

```json
{
  "mapData": {
    "type": "FeatureCollection",
    "features": [
      {
        "type": "Feature",
        "geometry": {
          "type": "Polygon",
          "coordinates": [
            [ [102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0] ]
          ]
        },
        "properties": {
          "featureType": "faction_territory",
          "name": "青云宗",
          "description": "东荒第一大宗，剑修圣地，山门连绵八百里。",
          "style": {
            "color": "#2a9d8f",
            "fillColor": "#2a9d8f",
            "fillOpacity": 0.4,
            "weight": 2
          }
        }
      },
      {
        "type": "Feature",
        "geometry": {
          "type": "Point",
          "coordinates": [102.5, 2.5]
        },
        "properties": {
          "featureType": "secret_realm",
          "name": "万剑冢",
          "description": "传闻是上古剑仙陨落之地，内藏无尽剑气与绝世神兵。",
          "icon": "sword-cave"
        }
      },
      {
        "type": "Feature",
        "geometry": {
          "type": "Point",
          "coordinates": [102.2, 2.8]
        },
        "properties": {
          "featureType": "city",
          "name": "云来城",
          "description": "青云宗山脚下的凡人城市，修士与凡人混居，极为繁华。",
          "icon": "city-gate"
        }
      }
    ]
  }
}
```

**核心字段解析:**
*   `type: "FeatureCollection"`: GeoJSON的标准根元素。
*   `features`: 一个包含所有地图元素的数组。
*   `geometry`: 定义元素的几何形状 (`Polygon` 用于势力范围, `Point` 用于地点/秘境)。
*   `properties`: 存储元素的元数据。
    *   `featureType`: 元素类型，用于区分渲染逻辑（势力范围、秘境、城市等）。
    *   `name`, `description`: 用于在弹窗中显示的信息。
    *   `style`: (用于多边形) 定义颜色、透明度等样式。
    *   `icon`: (用于点) 定义使用的自定义图标。

## 二、 法器铸造：`MapView.vue` 组件设计

此组件将是承载整个坤舆图志的核心。

```vue
<!-- src/views/MapView.vue -->
<template>
  <div id="map-container" ref="mapContainer"></div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import 'leaflet/dist/leaflet.css';
import L from 'leaflet';
import { generateMapData } from '@/utils/tavernAI'; // 假设的AI调用函数

const mapContainer = ref<HTMLElement | null>(null);
let map: L.Map | null = null;

onMounted(async () => {
  if (mapContainer.value) {
    // 1. 初始化坤舆图
    map = L.map(mapContainer.value).setView([51.505, -0.09], 2); // 初始视角

    // 2. 加载底图图层（可替换为古风画卷）
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // 3. 从AI获取地图数据
    const worldData = await generateMapData(); // 调用AI生成

    // 4. 渲染数据
    renderMapFeatures(worldData.mapData);
  }
});

function renderMapFeatures(geoJsonData: any) {
  if (!map) return;

  const geoJsonLayer = L.geoJSON(geoJsonData, {
    // 5. 为不同类型的Feature设置样式和交互
    style: (feature) => {
      // 如果是势力范围 (Polygon)，则使用其properties中定义的样式
      if (feature?.geometry.type === 'Polygon' && feature.properties.style) {
        return feature.properties.style;
      }
      return {};
    },
    pointToLayer: (feature, latlng) => {
      // 如果是地点 (Point)，则创建自定义图标的Marker
      if (feature?.geometry.type === 'Point' && feature.properties.icon) {
        // 此处需要一个函数来根据 icon 名称获取 L.Icon 实例
        // const customIcon = getIcon(feature.properties.icon);
        // return L.marker(latlng, { icon: customIcon });
        return L.marker(latlng); // 简化示例
      }
      return L.marker(latlng);
    },
    onEachFeature: (feature, layer) => {
      // 6. 为每个元素绑定弹窗 (Popup)
      if (feature.properties && feature.properties.name) {
        const popupContent = `
          <h4>${feature.properties.name}</h4>
          <p>${feature.properties.description || ''}</p>
        `;
        layer.bindPopup(popupContent);
      }
    }
  }).addTo(map);

  // 7. 自动缩放地图以适应所有元素
  map.fitBounds(geoJsonLayer.getBounds());
}

</script>

<style scoped>
#map-container {
  width: 100%;
  height: 100vh; /* 占满整个视口 */
}
</style>
```

## 三、 神通显化：核心实现逻辑

1.  **数据驱动渲染**: 核心思想是“数据决定地图”。我们不直接编写代码画一个“青云宗”，而是让AI生成一个带有“青云宗”属性和坐标的`Polygon`数据，然后由`renderMapFeatures`函数自动将其渲染出来。
2.  **样式与交互分离**:
    *   **势力范围 (`Polygon`)**: 样式（颜色、透明度）直接在AI生成的数据中定义，这样每个势力的视觉表现都可以由AI动态决定，增加了世界的生动性。
    *   **地点/秘境 (`Point`)**: 使用 `pointToLayer` 选项，我们可以根据 `feature.properties.icon` 的值，为其替换不同的自定义图标（例如，一个门派图标，一个洞府图标）。
    *   **信息交互 (`Popup`)**: 使用 `onEachFeature` 为每个图层绑定一个弹窗。当用户点击地图上的任何元素时，都会显示其`name`和`description`。

## 四、 未来展望：神识绘制 (`leaflet-draw`)

在完成基础的可视化后，下一步可引入 `leaflet-draw` 插件。
*   **GM/管理员功能**: 允许管理员在前端直接绘制、修改和删除势力范围，并将结果保存为GeoJSON，用于更新世界数据。
*   **玩家标记**: 允许玩家在自己的地图上做标记，如“标记洞府”、“规划路线”等，这些信息只对玩家自己可见，存储在本地或个人云端存档中。
