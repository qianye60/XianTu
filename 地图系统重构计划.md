# 地图系统重构计划

## 当前问题分析

### 现有系统的主要问题

1. ❌ **使用经纬度坐标系统** - `geoToVirtual`函数将经纬度转换为虚拟坐标，不适合修仙游戏世界
2. ❌ **依赖OpenLayers库** - `ol`是真实地球地图库，用于游戏场景过于复杂
3. ❌ **坐标系不合理** - 经纬度范围限制（100-130度经度，25-45度纬度）对游戏世界没有意义
4. ❌ **手动SVG绘制** - 缺乏专业游戏地图功能（图层管理、性能优化、特效支持）
5. ❌ **性能问题** - SVG在大量元素时性能较差

### 现有文件

- `src/components/dashboard/WorldMapPanel.vue` - 主地图组件（1966行）
- `src/components/dashboard/components/MapIcon.vue` - 地图图标组件
- 依赖：`ol` (OpenLayers)

---

## 重构方案

### 技术选型：Pixi.js

**选择理由：**

- ✅ 专为2D游戏设计的高性能WebGL渲染引擎
- ✅ 支持大地图平移、缩放、多图层管理
- ✅ 完全自定义坐标系（不依赖经纬度）
- ✅ 支持精灵、纹理、粒子效果、滤镜
- ✅ 轻量级（~500KB），与Vue 3兼容良好
- ✅ 丰富的插件生态（viewport、particles等）

**替代方案对比：**

| 方案     | 优点                   | 缺点               | 适用性     |
| -------- | ---------------------- | ------------------ | ---------- |
| Pixi.js  | 高性能、专业2D游戏引擎 | 学习曲线中等       | ⭐⭐⭐⭐⭐ |
| Phaser 3 | 功能全面、内置物理引擎 | 体积较大、过于复杂 | ⭐⭐⭐     |
| Konva.js | 简单易用、Canvas API   | 性能一般、功能有限 | ⭐⭐       |
| Three.js | 3D能力强大             | 2D场景过于复杂     | ⭐         |

---

## 详细实施计划

### 第一阶段：环境准备（30分钟）

#### 1.1 安装新依赖

```bash
npm install pixi.js @pixi/events pixi-viewport
npm uninstall ol leaflet.markercluster
```

**依赖说明：**

- `pixi.js` - 核心渲染引擎
- `@pixi/events` - 事件系统
- `pixi-viewport` - 地图视口插件（平移、缩放、边界限制）

#### 1.2 更新类型定义

创建 `src/types/gameMap.ts`：

```typescript
// 游戏地图坐标系统（像素坐标）
export interface GameCoordinates {
  x: number;  // 0 - 10000
  y: number;  // 0 - 10000
}

// 地图配置
export interface GameMapConfig {
  width: number;      // 地图总宽度（像素）
  height: number;     // 地图总高度（像素）
  tileSize: number;   // 网格大小
}

// 地图图层
export enum MapLayer {
  BACKGROUND = 0,   // 背景层
  TERRAIN = 1,      // 地形层
  CONTINENT = 2,    // 大陆层
  TERRITORY = 3,    // 势力范围层
  LOCATION = 4,     // 地点标记层
  PLAYER = 5,       // 玩家层
  UI = 6           // UI层
}
```

#### 1.3 修改现有类型

更新 `src/types/location.ts`：

```typescript
export interface WorldLocation {
  id: string;
  name: string;
  type: string;
  coordinates: GameCoordinates;  // 改为游戏坐标
  description: string;
  // 移除经纬度相关字段
}
```

---

### 第二阶段：核心组件重写（2-3小时）

#### 2.1 创建Pixi.js地图管理器

创建 `src/utils/gameMapManager.ts`：

```typescript
import * as PIXI from 'pixi.js';
import { Viewport } from 'pixi-viewport';

export class GameMapManager {
  private app: PIXI.Application;
  private viewport: Viewport;
  private layers: Map<MapLayer, PIXI.Container>;

  constructor(canvas: HTMLCanvasElement, config: GameMapConfig) {
    // 初始化Pixi应用
    this.app = new PIXI.Application({
      view: canvas,
      width: window.innerWidth,
      height: window.innerHeight,
      backgroundColor: 0xf8fafc,
      antialias: true,
      resolution: window.devicePixelRatio || 1,
      autoDensity: true
    });

    // 初始化视口（支持平移、缩放）
    this.viewport = new Viewport({
      worldWidth: config.width,
      worldHeight: config.height,
      screenWidth: window.innerWidth,
      screenHeight: window.innerHeight,
      interaction: this.app.renderer.plugins.interaction
    });

    // 配置视口行为
    this.viewport
      .drag()
      .pinch()
      .wheel()
      .decelerate()
      .clampZoom({ minScale: 0.1, maxScale: 4 });

    this.app.stage.addChild(this.viewport);

    // 初始化图层
    this.layers = new Map();
    this.initLayers();
  }

  private initLayers() {
    // 创建各个图层
    for (const layer of Object.values(MapLayer)) {
      if (typeof layer === 'number') {
        const container = new PIXI.Container();
        container.sortableChildren = true;
        this.layers.set(layer, container);
        this.viewport.addChild(container);
      }
    }
  }

  // 添加地点标记
  addLocation(location: WorldLocation) {
    const locationLayer = this.layers.get(MapLayer.LOCATION);
    // 实现地点标记绘制
  }

  // 添加大陆边界
  addContinent(continent: CultivationContinent) {
    const continentLayer = this.layers.get(MapLayer.CONTINENT);
    // 实现大陆边界绘制
  }

  // 更新玩家位置
  updatePlayerPosition(position: GameCoordinates) {
    const playerLayer = this.layers.get(MapLayer.PLAYER);
    // 实现玩家标记更新
  }

  // 居中到指定坐标
  centerTo(x: number, y: number) {
    this.viewport.moveCenter(x, y);
  }

  // 销毁
  destroy() {
    this.app.destroy(true, { children: true });
  }
}
```

#### 2.2 创建新地图组件

创建 `src/components/dashboard/GameMapPanel.vue`：

```vue
<template>
  <div class="game-map-panel">
    <!-- 世界信息头部 -->
    <div v-if="worldBackground" class="world-info-header">
      <div class="world-name">{{ worldName }}</div>
      <div class="world-background">{{ worldBackground }}</div>
    </div>

    <!-- Pixi.js Canvas容器 -->
    <div class="map-container" ref="mapContainerRef">
      <canvas ref="canvasRef"></canvas>

      <!-- 地图控制按钮 -->
      <div class="map-controls">
        <button @click="centerToPlayer" title="定位到玩家">
          <Target :size="16" />
        </button>
        <button @click="toggleFullscreen" title="全屏">
          <Maximize2 :size="16" />
        </button>
      </div>
    </div>

    <!-- 地点信息弹窗 -->
    <div v-if="selectedLocation" class="location-popup" :style="popupStyle">
      <div class="popup-header">
        <h4>{{ selectedLocation.name }}</h4>
        <button @click="selectedLocation = null">×</button>
      </div>
      <div class="popup-content">
        <p>{{ selectedLocation.description }}</p>
      </div>
    </div>

    <!-- 地图图例 -->
    <div class="map-legend">
      <div class="legend-title">{{ worldName }}图例</div>
      <div class="legend-items">
        <!-- 图例项 -->
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { Target, Maximize2 } from 'lucide-vue-next';
import { GameMapManager } from '@/utils/gameMapManager';
import { useGameStateStore } from '@/stores/gameStateStore';

const gameStateStore = useGameStateStore();
const canvasRef = ref<HTMLCanvasElement | null>(null);
const mapContainerRef = ref<HTMLDivElement | null>(null);
const mapManager = ref<GameMapManager | null>(null);
const selectedLocation = ref<WorldLocation | null>(null);

const worldName = computed(() => gameStateStore.worldInfo?.世界名称 || '修仙界');
const worldBackground = computed(() => gameStateStore.worldInfo?.世界背景 || '');

onMounted(() => {
  if (canvasRef.value) {
    // 初始化地图管理器
    mapManager.value = new GameMapManager(canvasRef.value, {
      width: 10000,
      height: 10000,
      tileSize: 100
    });

    // 加载地图数据
    loadMapData();
  }
});

onUnmounted(() => {
  mapManager.value?.destroy();
});

const loadMapData = () => {
  const worldInfo = gameStateStore.worldInfo;

  // 加载大陆
  worldInfo?.大陆信息?.forEach(continent => {
    mapManager.value?.addContinent(continent);
  });

  // 加载地点
  worldInfo?.地点信息?.forEach(location => {
    mapManager.value?.addLocation(location);
  });

  // 加载势力
  worldInfo?.势力信息?.forEach(faction => {
    mapManager.value?.addLocation(faction);
  });

  // 更新玩家位置
  const playerPos = gameStateStore.playerStatus?.位置;
  if (playerPos) {
    mapManager.value?.updatePlayerPosition(playerPos);
  }
};

const centerToPlayer = () => {
  const playerPos = gameStateStore.playerStatus?.位置;
  if (playerPos) {
    mapManager.value?.centerTo(playerPos.x, playerPos.y);
  }
};

const toggleFullscreen = () => {
  if (mapContainerRef.value) {
    if (document.fullscreenElement) {
      document.exitFullscreen();
    } else {
      mapContainerRef.value.requestFullscreen();
    }
  }
};
</script>

<style scoped>
.game-map-panel {
  display: flex;
  flex-direction: column;
  height: 100%;
  background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
}

.map-container {
  flex: 1;
  position: relative;
  overflow: hidden;
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
}

.map-controls {
  position: absolute;
  top: 12px;
  left: 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 1000;
}

.map-controls button {
  width: 36px;
  height: 36px;
  background: rgba(255, 255, 255, 0.95);
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.map-controls button:hover {
  background: white;
  border-color: #3b82f6;
  color: #3b82f6;
  box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2);
}

.map-legend {
  position: absolute;
  bottom: 20px;
  right: 20px;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(8px);
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
  z-index: 1000;
}
</style>
```

#### 2.3 实现地点标记渲染

在 `gameMapManager.ts` 中实现：

```typescript
addLocation(location: WorldLocation) {
  const locationLayer = this.layers.get(MapLayer.LOCATION);
  if (!locationLayer) return;

  // 创建地点容器
  const locationContainer = new PIXI.Container();
  locationContainer.x = location.coordinates.x;
  locationContainer.y = location.coordinates.y;
  locationContainer.interactive = true;
  locationContainer.buttonMode = true;

  // 绘制图标
  const icon = this.createLocationIcon(location.type, location.iconColor);
  locationContainer.addChild(icon);

  // 添加文字标签
  const label = new PIXI.Text(location.name, {
    fontFamily: 'Microsoft YaHei',
    fontSize: 12,
    fill: location.iconColor,
    fontWeight: 'bold'
  });
  label.anchor.set(0.5, 0);
  label.y = 20;
  locationContainer.addChild(label);

  // 添加交互事件
  locationContainer.on('pointerdown', () => {
    this.emit('locationClick', location);
  });

  locationContainer.on('pointerover', () => {
    locationContainer.scale.set(1.1);
  });

  locationContainer.on('pointerout', () => {
    locationContainer.scale.set(1);
  });

  locationLayer.addChild(locationContainer);
}

private createLocationIcon(type: string, color: string): PIXI.Graphics {
  const graphics = new PIXI.Graphics();
  const colorNum = parseInt(color.replace('#', ''), 16);

  switch (type) {
    case 'natural_landmark':
      // 绘制山形图标
      graphics.beginFill(colorNum, 0.8);
      graphics.moveTo(0, -12);
      graphics.lineTo(-8, 8);
      graphics.lineTo(8, 8);
      graphics.closePath();
      graphics.endFill();
      break;

    case 'sect_power':
      // 绘制建筑图标
      graphics.beginFill(colorNum, 0.8);
      graphics.drawRect(-8, -8, 16, 16);
      graphics.endFill();
      break;

    case 'city_town':
      // 绘制城市图标
      graphics.beginFill(colorNum, 0.8);
      graphics.drawCircle(0, 0, 10);
      graphics.endFill();
      break;

    default:
      // 默认圆形
      graphics.beginFill(colorNum, 0.8);
      graphics.drawCircle(0, 0, 8);
      graphics.endFill();
  }

  return graphics;
}
```

---

### 第三阶段：数据迁移（1小时）

#### 3.1 创建坐标转换工具

创建 `src/utils/coordinateConverter.ts`：

```typescript
/**
 * 将旧的经纬度坐标转换为新的游戏坐标
 * @param lng 经度 (100-130)
 * @param lat 纬度 (25-45)
 * @returns 游戏坐标 (0-10000)
 */
export function convertLngLatToGameCoords(lng: number, lat: number): GameCoordinates {
  const minLng = 100;
  const maxLng = 130;
  const minLat = 25;
  const maxLat = 45;

  const mapWidth = 10000;
  const mapHeight = 10000;

  // 线性映射
  const x = ((lng - minLng) / (maxLng - minLng)) * mapWidth;
  const y = ((maxLat - lat) / (maxLat - minLat)) * mapHeight;  // Y轴反转

  return { x, y };
}

/**
 * 批量转换地点数据
 */
export function convertLocationsData(locations: any[]): WorldLocation[] {
  return locations.map(loc => {
    let coordinates: GameCoordinates;

    if (loc.coordinates?.x !== undefined && loc.coordinates?.y !== undefined) {
      // 如果已经是游戏坐标，直接使用
      coordinates = loc.coordinates;
    } else if (loc.位置?.x !== undefined && loc.位置?.y !== undefined) {
      // 如果是经纬度，转换
      coordinates = convertLngLatToGameCoords(loc.位置.x, loc.位置.y);
    } else {
      // 随机生成
      coordinates = {
        x: Math.random() * 10000,
        y: Math.random() * 10000
      };
    }

    return {
      ...loc,
      coordinates
    };
  });
}
```

#### 3.2 更新世界生成逻辑

修改AI生成地点时的提示词，要求使用游戏坐标：

```typescript
// 在世界生成相关代码中
const prompt = `
生成修仙世界地点时，请使用以下坐标系统：
- 坐标范围：x: 0-10000, y: 0-10000
- 坐标格式：{ x: number, y: number }
- 不要使用经纬度

示例：
{
  "名称": "青云宗",
  "位置": { "x": 5000, "y": 3000 },
  "类型": "宗门势力"
}
`;
```

---

### 第四阶段：优化与测试（1-2小时）

#### 4.1 性能优化

- **视口裁剪**：只渲染可见区域的地点
- **LOD系统**：根据缩放级别显示不同详细程度
- **对象池**：复用PIXI对象减少GC
- **纹理图集**：合并小图标到一张纹理

#### 4.2 功能增强

- **小地图**：右下角显示全局小地图
- **路径绘制**：显示玩家移动路径
- **区域高亮**：鼠标悬停高亮区域
- **搜索功能**：快速定位地点
- **迷雾系统**：未探索区域显示迷雾

#### 4.3 测试清单

- [ ] 地图加载正常
- [ ] 平移、缩放流畅
- [ ] 地点点击交互正常
- [ ] 玩家定位功能正常
- [ ] 全屏模式正常
- [ ] 移动端触摸操作正常
- [ ] 性能测试（1000+地点）

---

## 文件变更清单

### 新增文件

- `src/types/gameMap.ts` - 游戏地图类型定义
- `src/utils/gameMapManager.ts` - Pixi.js地图管理器
- `src/utils/coordinateConverter.ts` - 坐标转换工具
- `src/components/dashboard/GameMapPanel.vue` - 新地图组件

### 修改文件

- `src/types/location.ts` - 更新坐标类型
- `src/types/worldMap.ts` - 更新地图配置类型
- `package.json` - 更新依赖

### 删除文件

- `src/components/dashboard/WorldMapPanel.vue` - 旧地图组件（备份后删除）
- 移除 `ol` 相关导入

---

## 预估工作量

| 阶段           | 任务         | 预估时间          |
| -------------- | ------------ | ----------------- |
| 第一阶段       | 环境准备     | 30分钟            |
| 第二阶段       | 核心组件重写 | 2-3小时           |
| 第三阶段       | 数据迁移     | 1小时             |
| 第四阶段       | 优化与测试   | 1-2小时           |
| **总计** |              | **5-7小时** |

---

## 风险与注意事项

### 潜在风险

1. **学习曲线**：团队需要熟悉Pixi.js API
2. **数据兼容**：现有存档数据需要迁移
3. **性能问题**：大量地点时需要优化渲染

### 缓解措施

1. 提供详细的代码注释和文档
2. 编写数据迁移脚本，保留旧数据备份
3. 实现LOD和视口裁剪优化性能

### 回滚方案

- 保留旧地图组件作为备份
- 使用feature flag控制新旧地图切换
- 确保数据格式向后兼容

---

## 后续扩展计划

### 短期（1-2周）

- [ ] 添加地图网格系统
- [ ] 实现区域天气效果
- [ ] 添加地点搜索功能

### 中期（1-2月）

- [ ] 实现迷雾探索系统
- [ ] 添加路径寻路功能
- [ ] 支持自定义地图皮肤

### 长期（3-6月）

- [ ] 3D地形渲染（可选）
- [ ] 实时多人位置显示
- [ ] 地图编辑器

---

## 参考资源

- [Pixi.js 官方文档](https://pixijs.com/docs)
- [pixi-viewport 插件](https://github.com/davidfig/pixi-viewport)
- [Pixi.js 示例](https://pixijs.com/examples)
- [游戏地图设计最佳实践](https://gamedevelopment.tutsplus.com/tutorials/introduction-to-game-map-design--cms-26612)

---

**文档版本**：v1.0
**创建日期**：2025-11-11
**最后更新**：2025-11-11
